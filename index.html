<!doctype html>
<html lang="en">
<head>
  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>maison joo — Botanical Set Design Studio</title>
  <meta name="description" content="French Korean botanical set design studio — Seoul & Paris. More coming soon." />
  <meta name="robots" content="index,follow" />
  <link rel="icon" type="image/png" href="/favicon.png" />
  <style>
    @font-face { font-family:"Minion Pro"; src:url("fonts/MinionPro-Regular.otf") format("opentype"); font-weight:400; font-style:normal; }
    @font-face { font-family:"Minion Pro"; src:url("fonts/MinionPro-Bold.otf") format("opentype"); font-weight:700; font-style:normal; }

    :root { --bg:#FDFAFA; --fg:#373737; }

    html, body { height:100%; margin:0; padding:0; overflow:hidden; background:var(--bg); color:var(--fg);
      font-family:"Minion Pro", serif; font-weight:400; letter-spacing:.01em; }

    /* Stage = fond + contenu */
    .stage { position:relative; width:100%; height:100vh; }

    /* Plasma en fond */
    #plasma-bg { position:fixed; inset:0; z-index:0; pointer-events:none; }

    /* Contenu au-dessus */
    .wrap { position:relative; z-index:1; height:100%; display:grid; place-content:center; text-align:center;
      padding:2rem; box-sizing:border-box; line-height:1.3; }

    .title { font-size:clamp(28px,6vw,48px); font-weight:400; letter-spacing:.05em; }
    .kicker { font-size:clamp(13px,2vw,16px); letter-spacing:.2em; text-transform:uppercase; opacity:.8; margin-top:1em; }
    .desc { font-size:clamp(14px,2.2vw,17px); text-transform:uppercase; letter-spacing:.1em; margin-top:1em; }
    .soon { margin-top:2em; font-weight:400; letter-spacing:.05em; }
    .contact { margin-top:2.4em; letter-spacing:.05em; font-size:14px; display:flex; flex-direction:column; align-items:center; gap:.3em; }
    .year { margin-top:3em; opacity:.7; letter-spacing:.2em; }
    a { color:inherit; text-decoration:underline; text-underline-offset:3px; }
  </style>
</head>
<body>
  <!-- Fond Plasma -->
  <div id="plasma-bg"></div>

  <!-- Contenu -->
  <main class="stage">
    <div class="wrap">
      <div class="title">maison joo</div>
      <div class="kicker">(SEOUL &amp; PARIS)</div>
      <div class="desc">BOTANICAL SET DESIGN STUDIO</div>
      <div class="soon">more coming soon</div>

      <div class="contact">
        contact
        <a href="mailto:contact@maisonjoo.com">EMAIL</a>
        <a href="tel:010-5725-9350">PHONE</a>
      </div>

      <div class="year">2025</div>
    </div>
  </main>

  <!-- Plasma vanilla avec OGL (ESM CDN) -->
  <script type="module">
    import { Renderer, Program, Mesh, Triangle } from "https://esm.sh/ogl@0.0.104";

    // === Réglages couleur/ambiance (adapte à ton site) ===
    const COLOR_HEX = "#373737";   // couleur “Maison Joo” (gris anthracite)
    const SPEED     = 0.6;         // 0.2–0.8 conseillé pour un rendu doux
    const SCALE     = 1.15;        // 1–1.3 pour des motifs lents
    const OPACITY   = 0.08;        // 0.05–0.12 pour rester subtil
    const MODE      = "pingpong";  // "forward" | "reverse" | "pingpong"
    const MOUSE     = true;        // léger drift au mouvement

    const hexToRgb = (hex) => {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!m) return [1, 1, 1];
      return [parseInt(m[1],16)/255, parseInt(m[2],16)/255, parseInt(m[3],16)/255];
    };

    const vertex = `#version 300 es
    precision highp float;
    in vec2 position; in vec2 uv; out vec2 vUv;
    void main(){ vUv=uv; gl_Position=vec4(position,0.,1.); }`;

    const fragment = `#version 300 es
    precision highp float;
    uniform vec2 iResolution; uniform float iTime;
    uniform vec3 uCustomColor; uniform float uUseCustomColor;
    uniform float uSpeed; uniform float uDirection; uniform float uScale;
    uniform float uOpacity; uniform vec2 uMouse; uniform float uMouseInteractive;
    out vec4 fragColor;

    void mainImage(out vec4 o, vec2 C){
      vec2 center=iResolution*.5; C=(C-center)/uScale+center;
      vec2 mouseOffset=(uMouse-center)*0.0002;
      C+=mouseOffset*length(C-center)*step(0.5,uMouseInteractive);
      float i,d,z,T=iTime*uSpeed*uDirection; vec3 O,p,S;
      for(vec2 r=iResolution.xy,Q; ++i<60.; O+=o.w/d*o.xyz){
        p=z*normalize(vec3(C-.5*r,r.y)); p.z-=4.; S=p; d=p.y-T;
        p.x+=.4*(1.+p.y)*sin(d + p.x*.1)*cos(.34*d + p.x*.05);
        Q=p.xz*=mat2(cos(p.y+vec4(0,11,33,0)-T));
        z+= d = abs(sqrt(length(Q*Q)) - .25*(5.+S.y))/3.+8e-4;
        o = 1.+sin(S.y+p.z*.5+S.z-length(S-p)+vec4(2,1,0,8));
      }
      o.xyz = tanh(O/1e4);
    }

    bool finite1(float x){ return !(isnan(x) || isinf(x)); }
    vec3 sanitize(vec3 c){
      return vec3(finite1(c.r)?c.r:0., finite1(c.g)?c.g:0., finite1(c.b)?c.b:0.);
    }

    void main(){
      vec4 o=vec4(0.); mainImage(o, gl_FragCoord.xy); vec3 rgb=sanitize(o.rgb);
      float intensity=(rgb.r+rgb.g+rgb.b)/3.; vec3 custom=intensity*uCustomColor;
      vec3 final=mix(rgb, custom, step(0.5, uUseCustomColor));
      float alpha=length(rgb)*uOpacity; fragColor=vec4(final, alpha);
    }`;

    const container = document.getElementById("plasma-bg");
    const renderer = new Renderer({ webgl:2, alpha:true, antialias:false, dpr:Math.min(devicePixelRatio||1,2) });
    const gl = renderer.gl; const canvas = gl.canvas;
    canvas.style.width="100%"; canvas.style.height="100%"; canvas.style.display="block";
    container.appendChild(canvas);

    const geometry = new Triangle(gl);
    const program = new Program(gl, {
      vertex, fragment,
      uniforms:{
        iTime:{ value:0 },
        iResolution:{ value:new Float32Array([1,1]) },
        uCustomColor:{ value:new Float32Array(hexToRgb(COLOR_HEX)) },
        uUseCustomColor:{ value:1.0 },
        uSpeed:{ value:SPEED*0.4 },
        uDirection:{ value: (MODE==="reverse"?-1.0:1.0) },
        uScale:{ value:SCALE },
        uOpacity:{ value:OPACITY },
        uMouse:{ value:new Float32Array([0,0]) },
        uMouseInteractive:{ value: MOUSE?1.0:0.0 }
      }
    });
    const mesh = new Mesh(gl,{ geometry, program });

    // Resize
    const setSize = () => {
      const r = container.getBoundingClientRect();
      const w = Math.max(1, Math.floor(r.width));
      const h = Math.max(1, Math.floor(r.height));
      renderer.setSize(w, h);
      const res = program.uniforms.iResolution.value; res[0]=gl.drawingBufferWidth; res[1]=gl.drawingBufferHeight;
    };
    new ResizeObserver(setSize).observe(container); setSize();

    // Mouse
    if (MOUSE) {
      container.addEventListener("mousemove", (e)=>{
        const rect = container.getBoundingClientRect();
        const u = program.uniforms.uMouse.value;
        u[0] = e.clientX - rect.left; u[1] = e.clientY - rect.top;
      });
    }

    // Loop (avec pingpong optionnel)
    const t0 = performance.now(); let raf=0;
    const loop = (t)=>{
      let time = (t - t0) * 0.001;
      if (MODE==="pingpong"){
        const D=10.; const seg=time % D; const forward=(Math.floor(time/D)%2===0);
        const u=seg/D; const smooth=u*u*(3.-2.*u); const tt=forward? smooth*D : (1.-smooth)*D;
        program.uniforms.uDirection.value = 1.0;
        program.uniforms.iTime.value = tt;
      } else {
        program.uniforms.iTime.value = time;
      }
      renderer.render({ scene: mesh });
      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);
    // (pas besoin de cleanup ici sur une page statique)
  </script>
</body>
</html>
